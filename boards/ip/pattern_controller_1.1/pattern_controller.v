`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: Xilinx
// Engineer: Parimal Patel
// Create Date: 01/10/2017 10:11:16 AM
// Module Name: pattern_controller
// Project Name: PYNQ
//////////////////////////////////////////////////////////////////////////////////

module pattern_controller #(parameter ADDR_WIDTH = 18)(
    input clk,
    // controls_input are multiple clocks wide as they are generated by GPIO write
	// [0] = start, [1] = stop, [2] = DPB, [3] = SMB, [4] = Trace only, [5] = Step
    input [5:0] controls_input,           
    input [ADDR_WIDTH-1:0] numSample,   // Maximum number of samples = BRAM depth = 128K Words
    input single_b,                     // =0 means single time, =1 multiple times
    input reset_n,
    output [ADDR_WIDTH-1:0] pattern_addrB,  // 64K Words, 256K Bytes
    output reg pattern_enb
    );
    
    reg step_executed=0, step_executed_1=0;
    
    wire start;
    wire stop;
    wire cnt_done;
    reg [ADDR_WIDTH-1:0] count;
    wire single_cnt_done;
    wire step;
	reg step_mode=0;
    
    // pulsed output generation
    pulse_gen sync_start(.async_in(controls_input[0]&controls_input[2]), .sync_clk(clk), .pulsed_out(start));
    pulse_gen sync_stop(.async_in(controls_input[1]&controls_input[2]), .sync_clk(clk), .pulsed_out(stop));
    pulse_gen sync_step(.async_in(controls_input[5]&controls_input[2]), .sync_clk(clk), .pulsed_out(step));

    assign cnt_done = (count == (numSample-1)) ? 1'b1 : 1'b0;
    assign single_cnt_done = (count == numSample) ? 1'b1 : 1'b0;

    assign pattern_addrB = count;
                   
    always @(posedge clk)
    if (!reset_n)
        step_mode <= 0;
    else if(stop) 
        step_mode <= 0;
    else if(step)
        step_mode <= 1;
    else 
        step_mode <= step_mode;

    always @(posedge clk)
    if (!reset_n)
        count <= 0;
    else if(start || ((cnt_done) & (pattern_enb) & (single_b)) || stop) 
        count <= 0;
    else if(pattern_enb & ~cnt_done)
        count <= count + 1;
    else 
        count <= count;

    always @(posedge clk)
    if (!reset_n)
    begin
        pattern_enb <= 0;    
        step_executed <= 0;
        step_executed_1 <= 0;
    end
    else
    begin
        if((start) && (step_mode==0)) // start asserted in non-step mode 
        begin
            pattern_enb <= 1;
            step_executed <= 0;
            step_executed_1 <= 0;
        end
        else if(stop)    // stop asserted
        begin
            pattern_enb <= 0;
            step_executed <= 0;
            step_executed_1 <= 0;
        end
        else if(step)
        begin
            pattern_enb <= 1;
            step_executed <= 1;
            step_executed_1 <= 0;
        end       
        else if(step_executed)
        begin
            step_executed <= 0;
            step_executed_1 <= 1;
            pattern_enb <=0;
        end
        else if(step_executed_1)
        begin
            step_executed_1 <= 0;
            pattern_enb <=0;
        end
        else if ((step_mode) && (single_cnt_done) && (single_b==0)) 
        begin
            pattern_enb <= 1;
        end
        else if((cnt_done) && (single_b))
        begin
            pattern_enb <= 1;                       
        end
        else
        begin
            pattern_enb <= pattern_enb;
            step_executed <= step_executed;
            step_executed_1 <= step_executed_1;
        end       
    end
endmodule
