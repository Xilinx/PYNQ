`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: Xilinx
// Engineer: Parimal Patel
// Create Date: 04/13/2017 
// Module Name: fsm_controller
// Project Name: PYNQ
//////////////////////////////////////////////////////////////////////////////////

module fsm_controller (
    input clk,
 	// controls_input are multiple clocks wide as they are generated by GPIO write
	// [0] = start, [1] = stop, [2] = PG, [3] = FSM, [4] = Trace only, [5] = Step
    input [5:0] controls_input,           
    input reset_n,
    output reg fsm_enb,
    output fsm_rst
    );
    
    reg step_executed, step_executed_1;
    reg fsm_enb_1d=0;

    reg stopped=0;
    reg step_executed_after_stopped; 
    
    wire start;
    wire stop;
    wire step;
    
    assign fsm_rst = (fsm_enb ^ fsm_enb_1d) & ~step_executed_1 & ~step_executed | step_executed_after_stopped;
    
    // pulsed output generation
    pulse_gen sync_start(.async_in(controls_input[0]&controls_input[3]), .sync_clk(clk), .pulsed_out(start));
    pulse_gen sync_stop(.async_in(controls_input[1]&controls_input[3]), .sync_clk(clk), .pulsed_out(stop));
    pulse_gen sync_step(.async_in(controls_input[5]&controls_input[3]), .sync_clk(clk), .pulsed_out(step));

    always @(posedge clk)
    if (!reset_n)
        fsm_enb_1d <= 0;
    else 
        fsm_enb_1d <= fsm_enb;
    
    always @(posedge clk)
    if (!reset_n)
    begin
        fsm_enb <= 0;    
        step_executed <= 0;
        step_executed_1 <= 0;
    end
    else
    begin
        if(start)         // start asserted
        begin
            fsm_enb <= 1;
            step_executed <= 0;
        end
        else if(stop)    // stop asserted
        begin
            fsm_enb <= 0;
            step_executed <= 0;
        end
        else if(step)
        begin
            fsm_enb <= 1;
            step_executed <= 1;
            step_executed_1 <= 0;
        end       
        else if(step_executed)
        begin
            step_executed <= 0;
            step_executed_1 <= 1;
            fsm_enb <=0;
        end
        else if(step_executed_1)
        begin
            step_executed_1 <= 0;
            fsm_enb <=0;
        end
        else
        begin
            fsm_enb <= fsm_enb;
            step_executed <= step_executed;
        end       
    end
	
    always @(posedge clk)
    if (!reset_n)
    begin
        step_executed_after_stopped <= 0;
        stopped <= 0;
    end
    else
    begin
        if(stop)    // stop asserted
        begin
            step_executed_after_stopped <= 0;
            stopped <= 1;
        end
        else if(stopped & step)
        begin
            step_executed_after_stopped <= 1;
            stopped <= 0;
        end       
        else if(step_executed_after_stopped)
        begin
            step_executed_after_stopped <= 0;
        end
        else
        begin
            step_executed_after_stopped <= step_executed_after_stopped;
        end       
    end    

endmodule
