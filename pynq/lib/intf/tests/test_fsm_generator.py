#   Copyright (c) 2016, Xilinx, Inc.
#   All rights reserved.
#
#   Redistribution and use in source and binary forms, with or without
#   modification, are permitted provided that the following conditions are met:
#
#   1.  Redistributions of source code must retain the above copyright notice,
#       this list of conditions and the following disclaimer.
#
#   2.  Redistributions in binary form must reproduce the above copyright
#       notice, this list of conditions and the following disclaimer in the
#       documentation and/or other materials provided with the distribution.
#
#   3.  Neither the name of the copyright holder nor the names of its
#       contributors may be used to endorse or promote products derived from
#       this software without specific prior written permission.
#
#   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
#   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
#   PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
#   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
#   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
#   OR BUSINESS INTERRUPTION). HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
#   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
#   OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
#   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


from time import sleep
import numpy as np
import pytest
from pynq import Overlay
from pynq.intf.pattern_generator import bitstring_to_int
from pynq.intf.pattern_generator import wave_to_bitstring
from pynq.intf import FSMGenerator
from pynq.intf.intf_const import PYNQZ1_DIO_SPECIFICATION


__author__ = "Yun Rock Qu"
__copyright__ = "Copyright 2016, Xilinx"
__email__ = "pynq_support@xilinx.com"


ol = Overlay('interface.bit')


@pytest.mark.run(order=48)
def test_fsm_generator():
    """Test for the Finite State Machine Generator class.

    The pattern generated by the FSM will be compared with the one specified.
    
    fsm_0 will test maximum number of 4096 samples.
    
    fsm_1 will test a minimum number of 16 samples.
    
    fsm_2 will test the case when no analyzer is specified.

    """
    if_id = 3
    pin_dict = PYNQZ1_DIO_SPECIFICATION['output_pin_map']
    first_3_pins = [k for k in list(pin_dict.keys())[:3]]
    out = first_3_pins[0]
    rst, dir = first_3_pins[1:3]
    max_num_samples = 4096
    min_num_samples = 16
    test_string1 = test_string2 = test_string3 = \
        test_string4 = test_string5 = ''
    fsm_spec = {'inputs': [('rst', rst), ('direction', dir)],
                'outputs': [('test', out)],
                'states': ['S0', 'S1', 'S2', 'S3'],
                'transitions': [['00', 'S0', 'S1', '0'],
                                ['01', 'S0', 'S3', '0'],
                                ['00', 'S1', 'S2', '0'],
                                ['01', 'S1', 'S0', '0'],
                                ['00', 'S2', 'S3', '0'],
                                ['01', 'S2', 'S1', '0'],
                                ['00', 'S3', 'S0', '1'],
                                ['01', 'S3', 'S2', '1'],
                                ['1-', '*', 'S0', '']]}
    fsm_0 = FSMGenerator(if_id, fsm_spec,
                       use_analyzer=True,
                       num_analyzer_samples=max_num_samples)

    # Start the FSM generator to generate pattern
    print(f"\nConnect {rst} to GND, and {dir} to 3V3.")
    input("Hit enter after done ...")

    fsm_0.config(frequency_mhz=10)
    assert 'bram_data_buf' not in fsm_0.intf.buffers, \
        'bram_data_buf is not freed after use.'
    fsm_0.arm()
    fsm_0.run()
    sleep(0.5)
    fsm_0.display()
    fsm_0.stop()

    for wavegroup in fsm_0.waveform.waveform_dict['signal']:
        if wavegroup[0] == 'analysis':
            for wavelane in wavegroup[1:]:
                if wavelane['name'] == 'test':
                    test_string1 = wavelane['wave']
    test_array1 = np.array(bitstring_to_int(wave_to_bitstring(test_string1)))

    tile1 = np.array([1, 0, 0, 0])
    matched = False
    for delay in range(4):
        tile2 = np.roll(tile1, delay)
        candidate_array = np.tile(tile2, int(max_num_samples / 4))
        # Excluding the first sample since it starts from reset
        if np.array_equal(candidate_array[1:], test_array1[1:]):
            matched = True
            break
    assert matched, 'Analysis not matching the generated pattern.'

    # Running it the second time
    fsm_0.config(frequency_mhz=100)
    assert 'bram_data_buf' not in fsm_0.intf.buffers, \
        'bram_data_buf is not freed after use.'
    fsm_0.arm()
    fsm_0.run()
    sleep(0.5)
    fsm_0.display()
    fsm_0.stop()

    for wavegroup in fsm_0.waveform.waveform_dict['signal']:
        if wavegroup[0] == 'analysis':
            for wavelane in wavegroup[1:]:
                if wavelane['name'] == 'test':
                    test_string2 = wavelane['wave']
    test_array2 = np.array(bitstring_to_int(wave_to_bitstring(test_string2)))

    matched = False
    for delay in range(4):
        tile2 = np.roll(tile1, delay)
        candidate_array = np.tile(tile2, int(max_num_samples / 4))
        # Excluding the first sample since it starts from reset
        if np.array_equal(candidate_array[1:], test_array2[1:]):
            matched = True
            break
    assert matched, 'Analysis not matching the generated pattern.'

    # Recapture, using state bits
    print(f"Connect both {rst} and {dir} to GND on Arduino header.")
    input("Hit enter after done ...")
    fsm_1 = FSMGenerator(if_id, fsm_spec,
                         use_analyzer=True,
                         use_state_bits=True,
                         num_analyzer_samples=min_num_samples)
    fsm_1.config(frequency_mhz=10)
    fsm_1.arm()
    fsm_1.run()
    sleep(0.5)
    fsm_1.display()
    fsm_1.stop()

    for wavegroup in fsm_1.waveform.waveform_dict['signal']:
        if wavegroup[0] == 'analysis':
            for wavelane in wavegroup[1:]:
                if wavelane['name'] == 'test':
                    test_string3 = wavelane['wave']
                if wavelane['name'] == 'state_bit0':
                    test_string4 = wavelane['wave']
                if wavelane['name'] == 'state_bit1':
                    test_string5 = wavelane['wave']
    test_array3 = np.array(bitstring_to_int(wave_to_bitstring(test_string3)))
    test_array4 = np.array(bitstring_to_int(wave_to_bitstring(test_string4)))
    test_array5 = np.array(bitstring_to_int(wave_to_bitstring(test_string5)))

    tile3 = np.array([0, 0, 0, 1])
    tile4 = np.array([0, 1, 0, 1])
    tile5 = np.array([0, 0, 1, 1])
    matched = False
    for delay in range(4):
        tile6 = np.roll(tile3, delay)
        tile7 = np.roll(tile4, delay)
        tile8 = np.roll(tile5, delay)
        candidate_array3 = np.tile(tile6, int(min_num_samples / 4))
        candidate_array4 = np.tile(tile7, int(min_num_samples / 4))
        candidate_array5 = np.tile(tile8, int(min_num_samples / 4))
        # Excluding the first sample since it starts from reset
        if np.array_equal(candidate_array3[1:], test_array3[1:]):
            assert np.array_equal(candidate_array4[1:], test_array4[1:]), \
                'State bit 0 not synchronized with output.'
            assert np.array_equal(candidate_array5[1:], test_array5[1:]), \
                'State bit 1 not synchronized with output.'
            matched = True
            break
    assert matched, 'Analysis result not matching the generated pattern.'

    # Running it the second time
    fsm_1.config(frequency_mhz=100)
    fsm_1.arm()
    fsm_1.run()
    sleep(0.5)
    fsm_1.display()
    fsm_1.stop()

    for wavegroup in fsm_1.waveform.waveform_dict['signal']:
        if wavegroup[0] == 'analysis':
            for wavelane in wavegroup[1:]:
                if wavelane['name'] == 'test':
                    test_string3 = wavelane['wave']
                if wavelane['name'] == 'state_bit0':
                    test_string4 = wavelane['wave']
                if wavelane['name'] == 'state_bit1':
                    test_string5 = wavelane['wave']
    test_array3 = np.array(bitstring_to_int(wave_to_bitstring(test_string3)))
    test_array4 = np.array(bitstring_to_int(wave_to_bitstring(test_string4)))
    test_array5 = np.array(bitstring_to_int(wave_to_bitstring(test_string5)))

    matched = False
    for delay in range(4):
        tile6 = np.roll(tile3, delay)
        tile7 = np.roll(tile4, delay)
        tile8 = np.roll(tile5, delay)
        candidate_array3 = np.tile(tile6, int(min_num_samples / 4))
        candidate_array4 = np.tile(tile7, int(min_num_samples / 4))
        candidate_array5 = np.tile(tile8, int(min_num_samples / 4))
        # Excluding the first sample since it starts from reset
        if np.array_equal(candidate_array3[1:], test_array3[1:]):
            assert np.array_equal(candidate_array4[1:], test_array4[1:]), \
                'State bit 0 not synchronized with output.'
            assert np.array_equal(candidate_array5[1:], test_array5[1:]), \
                'State bit 1 not synchronized with output.'
            matched = True
            break
    assert matched, 'Analysis result not matching the trace-only pattern.'

    fsm_2 = FSMGenerator(if_id, fsm_spec, use_analyzer=False)
    exception_raised = False
    try:
        fsm_2.display()
    except ValueError:
        exception_raised = True
    assert exception_raised, 'Should raise exception for display().'

    fsm_0.intf.reset_buffers()
    fsm_1.intf.reset_buffers()
    fsm_2.intf.reset_buffers()
    del fsm_0, fsm_1, fsm_2
    ol.reset()
